using Microsoft.EntityFrameworkCore;
using Microsoft.AspNetCore.Http.HttpResults;
using nam.Server.Data;
using nam.Server.Endpoints;
using nam.Server.Models.DTOs;
using nam.Server.Models.Entities;
using nam.Server.Services.Implementations;
using nam.Server.Services;
using nam.ServerTests.mock;

namespace nam.ServerTests
{
    
    [TestClass]
    public sealed class PasswordResetTests
    {
        private ApplicationDbContext _context = null!;
        private const string TestDbName = "TestDb_PasswordReset";
        private readonly IEmailService emailService = new LocalEmailService();
        // Uses StaticCodeService for predictable codes in validation tests
        private ICodeService codeService = new StaticCodeService(); 

        // Defines a constant for the code generated by the StaticCodeService
        private readonly string StaticAuthCode = new StaticCodeService().GenerateAuthCode();

        [TestInitialize]
        public void Setup()
        {
            var options = new DbContextOptionsBuilder<ApplicationDbContext>()
                .UseInMemoryDatabase(databaseName: $"{TestDbName}_{Guid.NewGuid()}")
                .Options;
        
            _context = new ApplicationDbContext(options);
            codeService = new StaticCodeService(); 
        }

        [TestCleanup]
        public void Cleanup()
        {
            _context.Database.EnsureDeleted();
            _context.Dispose();
        }

       

        [TestMethod]
        public async Task RequestPasswordReset_EmailNotExists_ReturnsNotFound()
        {
            // Arrange
            var request = new PasswordResetRequestDto { Email = "nonexistent@example.com" };

            // Act
            var result = await AuthEndpoints.RequestPasswordReset(request, _context, emailService, codeService);
           
            // Assert
            Assert.IsNotNull(result);
            Assert.IsInstanceOfType<NotFound<PasswordResetResponseDto>>(result);
            var notFoundResult = (NotFound<PasswordResetResponseDto>)result;
            Assert.IsNotNull(notFoundResult.Value);
            Assert.IsFalse(notFoundResult.Value.Success);
            Assert.AreEqual("The email not found", notFoundResult.Value.Message);

            var codesCount = await _context.ResetPasswordAuth.CountAsync();
            Assert.AreEqual(0, codesCount, "No reset code should be created.");
        }

        [TestMethod]
        public async Task RequestPasswordReset_EmailExists_CodeIsCreatedAndSaved()
        {
            // Arrange
            const string testEmail = "test@example.com";
            Guid testUserId = Guid.NewGuid();
            
            // Seed: Adds an existing user
            _context.Users.Add(new User { Id = testUserId, Email = testEmail, PasswordHash = "dummyhash" });
            await _context.SaveChangesAsync();

            var request = new PasswordResetRequestDto { Email = testEmail };
            var beforeRequest = DateTime.UtcNow;

            // Act
            var result = await AuthEndpoints.RequestPasswordReset(request, _context, emailService, codeService);

            // Assert
            Assert.IsInstanceOfType<Ok<PasswordResetResponseDto>>(result);
            var savedCode = await _context.ResetPasswordAuth
                                        .FirstOrDefaultAsync(c => c.UserId == testUserId.ToString());

            Assert.IsNotNull(savedCode, "A reset code must be saved.");
            
            // Verify that the saved code matches the static code generated by StaticCodeService
            Assert.AreEqual(StaticAuthCode, savedCode.AuthCode, "The saved code must match the generated static code.");
            Assert.AreEqual(6, savedCode.AuthCode.Length);
            
            // Verify expiration timestamps (around 15 minutes)
            var afterRequest = DateTime.UtcNow;
            
            Assert.IsTrue(savedCode.ExpiresAt > beforeRequest.AddMinutes(14), 
                "ExpiresAt should be roughly 15 minutes in the future.");
            
            Assert.IsTrue(savedCode.ExpiresAt < afterRequest.AddMinutes(16), 
                "ExpiresAt should not be wildly different from 15 minutes.");
            
            Assert.AreEqual(testUserId.ToString(), savedCode.UserId);
        }

        [TestMethod]
        public async Task RequestPasswordReset_ExistingCodeIsOverwritten()
        {
            // Arrange
            const string testEmail = "overwrite@example.com";
            Guid testUserId = Guid.NewGuid();
            
            // 1. Seed User
            _context.Users.Add(new User { Id = testUserId, Email = testEmail, PasswordHash = "dummyhash" });

            // 2. Seed OLD Code (which should be overwritten)
            var oldAuthCode = "999999"; 
            var oldExpiration = DateTime.UtcNow.AddMinutes(5); 
            
            _context.ResetPasswordAuth.Add(new PasswordResetCode 
            {
                UserId = testUserId.ToString(),
                AuthCode = oldAuthCode,
                ExpiresAt = oldExpiration,
                CreatedAt = DateTime.UtcNow.AddMinutes(-10)
            });
            await _context.SaveChangesAsync();

            var request = new PasswordResetRequestDto { Email = testEmail };
            var beforeSecondRequest = DateTime.UtcNow;

            // Act - Second reset request
            var result = await AuthEndpoints.RequestPasswordReset(request, _context, emailService, codeService);

            // Assert
            Assert.IsInstanceOfType<Ok<PasswordResetResponseDto>>(result);

            // Only ONE code should exist (the old one was updated/removed and replaced)
            var codesCount = await _context.ResetPasswordAuth.CountAsync();
            Assert.AreEqual(1, codesCount, "Only one reset code should exist for the user.");

            var updatedCode = await _context.ResetPasswordAuth.SingleAsync();

            // The code must be the new one (StaticAuthCode) and the date updated
            Assert.AreEqual(StaticAuthCode, updatedCode.AuthCode, "The AuthCode must have been updated.");
            Assert.AreNotEqual(oldExpiration, updatedCode.ExpiresAt, "ExpiresAt must have been updated.");
            Assert.IsTrue(updatedCode.ExpiresAt > beforeSecondRequest.AddMinutes(14), 
                "ExpiresAt should be approximately 15 minutes in the future from the second request.");
        }

        
        [TestMethod]
        public async Task ResetPassword_ExpiredCode_ReturnsBadRequest()
        {
            // Arrange
            const string testEmail = "expired@example.com";
            Guid testUserId = Guid.NewGuid();
            
            // 1. Seed User
            _context.Users.Add(new User { Id = testUserId, Email = testEmail, PasswordHash = "dummyhash" });

            // 2. Seed MANUALLY EXPIRED Code
            var expiredTime = DateTime.UtcNow.AddMinutes(-5); // 5 minutes in the past
            _context.ResetPasswordAuth.Add(new PasswordResetCode 
            {
                UserId = testUserId.ToString(),
                AuthCode = StaticAuthCode,
                CreatedAt = expiredTime.AddMinutes(-15),
                ExpiresAt = expiredTime
            });
            await _context.SaveChangesAsync();

            var request = new PasswordResetConfirmDto 
            { 
                AuthCode = StaticAuthCode,
                NewPassword = "mock_password_1",
                ConfirmPassword ="mock_password_1",
            };

            // Act: Call the password reset endpoint
            var result = await AuthEndpoints.ResetPassword(request, _context); 

            // Assert
            Assert.IsInstanceOfType<BadRequest<PasswordResetResponseDto>>(result, "Expired code must return a BadRequest error.");
           
            var badRequestResult = (BadRequest<PasswordResetResponseDto>)result;
            Assert.IsNotNull(badRequestResult.Value);
            Assert.IsFalse(badRequestResult.Value.Success);
            Assert.IsTrue(badRequestResult.Value.Message.ToLower().Contains("expired"), "The message must indicate expiration.");
        }

        [TestMethod]
        public async Task ResetPassword_ValidCode_SucceedsAndRemovesCode()
        {
            // Arrange
            const string testEmail = "valid@example.com";
            Guid testUserId = Guid.NewGuid();
            const string oldHash = "old_password_hash";
            
            _context.Users.Add(new User { Id = testUserId, Email = testEmail, PasswordHash = oldHash });
        
            var validTime = DateTime.UtcNow.AddMinutes(5); 
            _context.ResetPasswordAuth.Add(new PasswordResetCode 
            {
                UserId = testUserId.ToString(),
                AuthCode = StaticAuthCode,
                ExpiresAt = validTime,
                CreatedAt = DateTime.UtcNow
            });
            await _context.SaveChangesAsync();

            var newPassword = "new_secure_password_123";
            var request = new PasswordResetConfirmDto 
            { 
                AuthCode = StaticAuthCode,
                NewPassword = newPassword,
                ConfirmPassword = newPassword,
            };

            // Act: Call the password reset endpoint
            var result = await AuthEndpoints.ResetPassword(request, _context); 

            
            // Verify response
            Assert.IsInstanceOfType<Ok<PasswordResetResponseDto>>(result,  "Valid code should lead to a successful reset.");
            
            var okResult = (Ok<PasswordResetResponseDto>)result;
            Assert.IsNotNull(okResult.Value);
            Assert.IsTrue(okResult.Value.Success);
            
            // Verify that the code was removed from the DB
            var codeExists = await _context.ResetPasswordAuth
                                          .AnyAsync(c => c.UserId == testUserId.ToString());
            Assert.IsFalse(codeExists, "The reset code should be removed after success.");
            
            // Verify that the password hash was updated 
            var updatedUser = await _context.Users.FindAsync(testUserId);
            Assert.IsNotNull(updatedUser);
            Assert.AreNotEqual(oldHash, updatedUser.PasswordHash, "The user's password hash must have changed.");
        }
        
        [TestMethod]
        public async Task ResetPassword_IncorrectCode_ReturnsBadRequest()
        {
            // Arrange
            const string testEmail = "wrongcode@example.com";
            Guid testUserId = Guid.NewGuid();
            
            _context.Users.Add(new User { Id = testUserId, Email = testEmail, PasswordHash = "dummyhash" });

            // Seed CORRECT and valid Code
            var correctCode = "555555";
            var validTime = DateTime.UtcNow.AddMinutes(5); 
            _context.ResetPasswordAuth.Add(new PasswordResetCode 
            {
                UserId = testUserId.ToString(),
                AuthCode = correctCode, 
                ExpiresAt = validTime,
                CreatedAt = DateTime.UtcNow
            });
            await _context.SaveChangesAsync();

            var request = new PasswordResetConfirmDto 
            { 
                AuthCode = "999999", 
                NewPassword = "new_secure_password_123",
                ConfirmPassword = "new_secure_password_123"
            };

            // Act: Call the password reset endpoint
            var result = await AuthEndpoints.ResetPassword(request, _context); 

            // Assert
            Assert.IsInstanceOfType<BadRequest<PasswordResetResponseDto>>(result);
            
            var badRequestResult = (BadRequest<PasswordResetResponseDto>)result;
            Assert.IsNotNull(badRequestResult.Value);
            Assert.IsFalse(badRequestResult.Value.Success);
            Assert.IsTrue(badRequestResult.Value.Message.ToLower().Contains("invalid") || badRequestResult.Value.Message.ToLower().Contains("not found"), 
                "The message must indicate that the code is invalid or not found.");

            // The correct code should NOT be removed upon a failed validation attempt
            var codeExists = await _context.ResetPasswordAuth.AnyAsync();
            Assert.IsTrue(codeExists, "The correct code should remain in the DB after a failed attempt.");
        }
    }
}